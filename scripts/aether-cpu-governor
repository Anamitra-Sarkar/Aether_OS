#!/bin/bash
# =============================================================================
# AetherOS Dynamic CPU Governor Controller
# Rule-based CPU performance scaling with context awareness
# =============================================================================

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================
readonly VERSION="1.0.0"
readonly STATE_DIR="${HOME}/.local/share/aetheros/cpu-governor"
readonly OVERRIDE_FILE="${STATE_DIR}/manual-override"
readonly LOG_FILE="${STATE_DIR}/governor.log"
readonly LAST_CHANGE_FILE="${STATE_DIR}/last-automatic-change"
readonly MIN_DWELL_SECONDS=30
readonly FOREGROUND_ALLOWED="${AETHER_GOVERNOR_FOREGROUND:-false}"

readonly RED="\033[0;31m"
readonly YELLOW="\033[0;33m"
readonly GREEN="\033[0;32m"
readonly BLUE="\033[0;34m"
readonly CYAN="\033[0;36m"
readonly BOLD="\033[1m"
readonly RESET="\033[0m"

# Governor policies
readonly GOVERNOR_PERFORMANCE="performance"
readonly GOVERNOR_SCHEDUTIL="schedutil"
readonly GOVERNOR_POWERSAVE="powersave"
readonly GOVERNOR_ONDEMAND="ondemand"

# =============================================================================
# Utility Functions
# =============================================================================
log_info() {
    echo -e "${BLUE}[INFO]${RESET} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${RESET} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${RESET} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${RESET} $1"
}

ensure_directories() {
    mkdir -p "$STATE_DIR"
}

log_to_file() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE" 2>/dev/null || true
}

# =============================================================================
# CPU Detection Functions
# =============================================================================
get_cpu_count() {
    nproc 2>/dev/null || echo "1"
}

detect_cpu_vendor() {
    if [[ -f /proc/cpuinfo ]]; then
        if grep -qi "Intel" /proc/cpuinfo; then
            echo "intel"
        elif grep -qi "AMD" /proc/cpuinfo; then
            echo "amd"
        elif grep -qi "ARM" /proc/cpuinfo; then
            echo "arm"
        else
            echo "unknown"
        fi
    else
        echo "unknown"
    fi
}

get_available_governors() {
    local cpu_path="/sys/devices/system/cpu/cpu0/cpufreq"
    
    if [[ -f "${cpu_path}/scaling_available_governors" ]]; then
        cat "${cpu_path}/scaling_available_governors" 2>/dev/null || echo ""
    else
        echo ""
    fi
}

get_current_governor() {
    local cpu_path="/sys/devices/system/cpu/cpu0/cpufreq"
    
    if [[ -f "${cpu_path}/scaling_governor" ]]; then
        cat "${cpu_path}/scaling_governor" 2>/dev/null || echo "unknown"
    else
        echo "unknown"
    fi
}

is_governor_available() {
    local governor=$1
    local available=$(get_available_governors)
    
    if [[ "$available" =~ $governor ]]; then
        return 0
    else
        return 1
    fi
}

# =============================================================================
# Context Detection Functions
# =============================================================================
detect_battery_state() {
    # Check if on battery power
    if [[ -d /sys/class/power_supply ]]; then
        for supply in /sys/class/power_supply/*/type; do
            if [[ -f "$supply" ]] && grep -q "Battery" "$supply" 2>/dev/null; then
                local supply_dir=$(dirname "$supply")
                local status_file="${supply_dir}/status"
                
                if [[ -f "$status_file" ]]; then
                    local status=$(cat "$status_file" 2>/dev/null || echo "Unknown")
                    
                    if [[ "$status" == "Discharging" ]]; then
                        echo "battery"
                        return 0
                    elif [[ "$status" == "Charging" ]] || [[ "$status" == "Full" ]]; then
                        echo "ac"
                        return 0
                    fi
                fi
            fi
        done
    fi
    
    # Default to AC if can't determine
    echo "ac"
}

detect_thermal_state() {
    # Check CPU temperature
    local max_temp=0
    
    # Try thermal zones first
    if [[ -d /sys/class/thermal ]]; then
        for zone in /sys/class/thermal/thermal_zone*/temp; do
            if [[ -f "$zone" ]]; then
                local temp=$(cat "$zone" 2>/dev/null || echo "0")
                # Convert to Celsius (value is in millidegrees)
                temp=$((temp / 1000))
                
                if [[ $temp -gt $max_temp ]]; then
                    max_temp=$temp
                fi
            fi
        done
    fi
    
    # Try hwmon sensors
    if [[ $max_temp -eq 0 ]] && [[ -d /sys/class/hwmon ]]; then
        for sensor in /sys/class/hwmon/hwmon*/temp*_input; do
            if [[ -f "$sensor" ]]; then
                local temp=$(cat "$sensor" 2>/dev/null || echo "0")
                temp=$((temp / 1000))
                
                if [[ $temp -gt $max_temp ]]; then
                    max_temp=$temp
                fi
            fi
        done
    fi
    
    # Classify thermal state
    if [[ $max_temp -gt 85 ]]; then
        echo "hot"
    elif [[ $max_temp -gt 75 ]]; then
        echo "warm"
    else
        echo "normal"
    fi
}

detect_foreground_app() {
    # Foreground detection is optional and must be explicitly enabled
    if [[ "$FOREGROUND_ALLOWED" != "true" ]]; then
        echo "unknown"
        return
    fi

    # Try to detect foreground application category (best-effort, non-deterministic)
    local app_type="desktop"
    
    # Check for gaming applications
    if pgrep -i "steam|lutris|wine|proton|gamemode" &>/dev/null; then
        app_type="gaming"
    # Check for media applications
    elif pgrep -i "vlc|mpv|kodi|plex|spotify" &>/dev/null; then
        app_type="media"
    # Check for browsers with video
    elif pgrep -i "firefox|chrome|chromium" &>/dev/null; then
        # Could be watching video, but we don't know for sure
        app_type="browser"
    # Check for productivity apps
    elif pgrep -i "libreoffice|gimp|inkscape|blender|kdenlive" &>/dev/null; then
        app_type="productivity"
    # Check if system is idle
    elif command -v xprintidle &>/dev/null; then
        local idle_ms=$(xprintidle 2>/dev/null || echo "0")
        local idle_sec=$((idle_ms / 1000))
        
        if [[ $idle_sec -gt 300 ]]; then
            app_type="idle"
        fi
    fi
    
    echo "$app_type"
}

detect_cpu_load() {
    # Get 1-minute load average
    local load=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
    local cpu_count=$(get_cpu_count)
    
    # Calculate load per CPU
    local load_per_cpu=$(echo "scale=2; $load / $cpu_count" | bc -l 2>/dev/null || echo "0")
    
    # Classify load
    if (( $(echo "$load_per_cpu > 0.8" | bc -l 2>/dev/null || echo "0") )); then
        echo "high"
    elif (( $(echo "$load_per_cpu > 0.3" | bc -l 2>/dev/null || echo "0") )); then
        echo "medium"
    else
        echo "low"
    fi
}

# =============================================================================
# Governor Selection Logic
# =============================================================================
select_optimal_governor() {
    local battery=$(detect_battery_state)
    local thermal=$(detect_thermal_state)
    local app=$(detect_foreground_app)
    local load=$(detect_cpu_load)
    
    local selected_governor=""
    local reason=""
    
    # Rule 1: Thermal throttling takes precedence
    if [[ "$thermal" == "hot" ]]; then
        selected_governor="$GOVERNOR_POWERSAVE"
        reason="High temperature ($thermal) - thermal protection"
    
    # Rule 2: Gaming or high load needs performance
    elif [[ "$app" == "gaming" ]] || [[ "$load" == "high" ]]; then
        if [[ "$battery" == "ac" ]]; then
            selected_governor="$GOVERNOR_PERFORMANCE"
            reason="High load/gaming on AC power"
        else
            # On battery, use ondemand for gaming if available
            if is_governor_available "$GOVERNOR_ONDEMAND"; then
                selected_governor="$GOVERNOR_ONDEMAND"
                reason="High load on battery - balanced performance"
            else
                selected_governor="$GOVERNOR_SCHEDUTIL"
                reason="High load on battery - dynamic scaling"
            fi
        fi
    
    # Rule 3: Battery saver mode
    elif [[ "$battery" == "battery" ]] && [[ "$app" == "idle" ]]; then
        selected_governor="$GOVERNOR_POWERSAVE"
        reason="Idle on battery power - power saving"
    
    # Rule 4: Battery with activity
    elif [[ "$battery" == "battery" ]]; then
        if is_governor_available "$GOVERNOR_SCHEDUTIL"; then
            selected_governor="$GOVERNOR_SCHEDUTIL"
            reason="Battery power - efficient scaling"
        elif is_governor_available "$GOVERNOR_ONDEMAND"; then
            selected_governor="$GOVERNOR_ONDEMAND"
            reason="Battery power - demand-based scaling"
        else
            selected_governor="$GOVERNOR_POWERSAVE"
            reason="Battery power - power saving"
        fi
    
    # Rule 5: AC power normal usage
    else
        if is_governor_available "$GOVERNOR_SCHEDUTIL"; then
            selected_governor="$GOVERNOR_SCHEDUTIL"
            reason="AC power - normal desktop usage"
        elif is_governor_available "$GOVERNOR_ONDEMAND"; then
            selected_governor="$GOVERNOR_ONDEMAND"
            reason="AC power - demand-based scaling"
        elif is_governor_available "$GOVERNOR_PERFORMANCE"; then
            selected_governor="$GOVERNOR_PERFORMANCE"
            reason="AC power - maximum performance"
        else
            selected_governor="$GOVERNOR_POWERSAVE"
            reason="Fallback governor"
        fi
    fi
    
    echo "${selected_governor}|${reason}"
}

# =============================================================================
# Governor Control Functions
# =============================================================================
set_governor() {
    local governor=$1
    local cpu_count=$(get_cpu_count)
    
    # Check if governor is available
    if ! is_governor_available "$governor"; then
        log_error "Governor '$governor' is not available on this system"
        log_info "Available governors: $(get_available_governors)"
        return 1
    fi
    
    # Check if we have permission
    local test_path="/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"
    if [[ ! -w "$test_path" ]]; then
        log_error "Permission denied. Run with sudo to change governor."
        return 1
    fi
    
    # Set governor for all CPUs
    local success_count=0
    for cpu_num in $(seq 0 $((cpu_count - 1))); do
        local gov_path="/sys/devices/system/cpu/cpu${cpu_num}/cpufreq/scaling_governor"
        
        if [[ -f "$gov_path" ]]; then
            if echo "$governor" > "$gov_path" 2>/dev/null; then
                ((success_count++))
            fi
        fi
    done
    
    if [[ $success_count -eq $cpu_count ]]; then
        log_success "Governor set to '$governor' on all $cpu_count CPUs"
        log_to_file "Governor changed to $governor"
        return 0
    else
        log_error "Failed to set governor on some CPUs ($success_count/$cpu_count succeeded)"
        return 1
    fi
}

# =============================================================================
# Override Management
# =============================================================================
set_override() {
    local governor=$1
    
    ensure_directories
    echo "$governor" > "$OVERRIDE_FILE"
    log_success "Manual override set to '$governor'"
    log_info "Override will persist until cleared with 'aether-cpu-governor auto'"
}

clear_override() {
    if [[ -f "$OVERRIDE_FILE" ]]; then
        rm -f "$OVERRIDE_FILE"
        log_success "Manual override cleared"
    else
        log_info "No manual override was active"
    fi
}

get_override() {
    if [[ -f "$OVERRIDE_FILE" ]]; then
        cat "$OVERRIDE_FILE" 2>/dev/null || echo ""
    else
        echo ""
    fi
}

# =============================================================================
# Commands
# =============================================================================
cmd_auto() {
    log_info "Setting governor automatically based on system context..."
    local allow_resume=false
    ensure_directories
    for arg in "$@"; do
        if [[ "$arg" == "--resume" ]]; then
            allow_resume=true
        fi
    done

    # Respect manual override unless explicitly resumed
    local current_override=$(get_override)
    if [[ -n "$current_override" ]] && [[ "$allow_resume" == "false" ]]; then
        log_warn "Manual override '$current_override' active - automation paused"
        log_info "Run 'aether-cpu-governor auto --resume' to re-enable automation"
        return 0
    fi

    if [[ "$allow_resume" == "true" ]]; then
        clear_override
    fi
    
    # Detect optimal governor
    local result=$(select_optimal_governor)
    local governor=$(echo "$result" | cut -d'|' -f1)
    local reason=$(echo "$result" | cut -d'|' -f2)
    
    log_info "Selected: $governor"
    log_info "Reason: $reason"

    # Oscillation protection
    local now=$(date +%s)
    if [[ -f "$LAST_CHANGE_FILE" ]]; then
        local last_change
        last_change=$(cat "$LAST_CHANGE_FILE" 2>/dev/null | head -1 | grep -E '^[0-9]+$' || echo "0")
        local elapsed=$((now - last_change))
        if [[ $elapsed -lt $MIN_DWELL_SECONDS ]]; then
            log_warn "Dwell timer active (${elapsed}s < ${MIN_DWELL_SECONDS}s); skipping change"
            return 0
        fi
    fi
    
    # Set the governor
    if set_governor "$governor"; then
        echo "$now" > "$LAST_CHANGE_FILE"
    fi
}

cmd_set() {
    local governor=$1
    
    if [[ -z "$governor" ]]; then
        log_error "Governor name required"
        log_info "Available governors: $(get_available_governors)"
        return 1
    fi
    
    # Set override
    set_override "$governor"
    
    # Apply governor
    set_governor "$governor"
}

cmd_status() {
    echo -e "${BOLD}${CYAN}CPU Governor Status${RESET}"
    echo ""
    
    # CPU info
    local vendor=$(detect_cpu_vendor)
    local cpu_count=$(get_cpu_count)
    echo -e "${BOLD}CPU:${RESET} $vendor ($cpu_count cores)"
    
    # Current governor
    local current=$(get_current_governor)
    echo -e "${BOLD}Current Governor:${RESET} $current"
    
    # Available governors
    local available=$(get_available_governors)
    echo -e "${BOLD}Available Governors:${RESET} $available"
    
    echo ""
    
    # Check for override
    local override=$(get_override)
    if [[ -n "$override" ]]; then
        echo -e "${YELLOW}Manual Override Active:${RESET} $override"
        echo -e "${BOLD}Reason:${RESET} User-specified governor"
    else
        # Show context
        echo -e "${GREEN}Automatic Mode Active${RESET}"
        
        local result=$(select_optimal_governor)
        local optimal=$(echo "$result" | cut -d'|' -f1)
        local reason=$(echo "$result" | cut -d'|' -f2)
        
        echo -e "${BOLD}Optimal Governor:${RESET} $optimal"
        echo -e "${BOLD}Reason:${RESET} $reason"
        
        if [[ "$current" != "$optimal" ]]; then
            echo ""
            echo -e "${YELLOW}Note: Current governor differs from optimal${RESET}"
            echo -e "${BOLD}Run 'sudo aether-cpu-governor auto' to apply optimal governor${RESET}"
        fi
    fi
    
    echo ""
    
    # Context information
    echo -e "${BOLD}System Context:${RESET}"
    echo -e "  Battery: $(detect_battery_state)"
    echo -e "  Thermal: $(detect_thermal_state)"
    echo -e "  Load: $(detect_cpu_load)"
    local app_category=$(detect_foreground_app)
    if [[ "$app_category" == "unknown" ]] && [[ "$FOREGROUND_ALLOWED" != "true" ]]; then
        echo -e "  App Category: unavailable (foreground detection disabled)"
    else
        echo -e "  App Category: $app_category"
    fi
}

cmd_list() {
    echo -e "${BOLD}Available CPU Governors:${RESET}"
    echo ""
    
    local available=$(get_available_governors)
    
    for governor in $available; do
        local current=$(get_current_governor)
        local marker=""
        
        if [[ "$governor" == "$current" ]]; then
            marker=" ${GREEN}(active)${RESET}"
        fi
        
        echo -e "  • ${BOLD}$governor${RESET}$marker"
        
        # Add description
        case "$governor" in
            performance)
                echo "    Maximum CPU performance at all times"
                ;;
            powersave)
                echo "    Minimum power consumption, lowest frequencies"
                ;;
            schedutil)
                echo "    Scheduler-based frequency scaling (recommended)"
                ;;
            ondemand)
                echo "    Dynamic frequency scaling based on load"
                ;;
            conservative)
                echo "    Gradual frequency scaling based on load"
                ;;
            userspace)
                echo "    Manual frequency control"
                ;;
        esac
        echo ""
    done
}

show_help() {
    cat <<EOF
AetherOS Dynamic CPU Governor Controller v${VERSION}
Rule-based CPU performance scaling with context awareness

USAGE:
    aether-cpu-governor <command> [options]

COMMANDS:
    auto            Automatically select optimal governor based on context
    set <governor>  Manually set a specific governor
    status          Show current governor and system context
    list            List all available governors
    help            Show this help message

DESCRIPTION:
    Intelligently manages CPU governor selection based on:
    • Battery state (AC / battery)
    • Thermal state (normal / warm / hot)
    • Foreground application category
    • CPU load

GOVERNOR SELECTION RULES:
    • High temperature → powersave (thermal protection)
    • Gaming/high load on AC → performance
    • Gaming/high load on battery → schedutil/ondemand
    • Idle on battery → powersave
    • Battery with activity → schedutil
    • AC normal usage → schedutil

EXAMPLES:
    # Apply automatic governor selection
    sudo aether-cpu-governor auto

    # Manually lock to performance mode
    sudo aether-cpu-governor set performance

    # Check current status
    aether-cpu-governor status

    # List available governors
    aether-cpu-governor list

NOTES:
    • Requires root/sudo to change governors
    • Manual override persists until cleared with 'auto'
    • Supports Intel, AMD, and ARM CPUs (where cpufreq is available)
    • Foreground heuristics are disabled by default; set AETHER_GOVERNOR_FOREGROUND=true to allow them
    • Use 'auto --resume' to explicitly clear a manual override

EOF
}

# =============================================================================
# Main Function
# =============================================================================
main() {
    if [[ $# -eq 0 ]]; then
        cmd_status
        exit 0
    fi
    
    local command=$1
    shift
    
    case "$command" in
        auto)
            cmd_auto "$@"
            ;;
        set)
            cmd_set "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo "Use 'aether-cpu-governor help' for usage information" >&2
            exit 1
            ;;
    esac
}

main "$@"
